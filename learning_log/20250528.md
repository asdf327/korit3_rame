npm install @emotion/react@11.14.0
npm install @emotion/styled@11.14.0
npm install @tanstack/react-query@4.36.1
npm install axios

```tsx
import { AppBar, Toolbar, Typography, Container, CssBaseline } from "@mui/material"

function App() {
  

  return (
    <Container maxWidth="xl">
    <CssBaseline />
      <AppBar position="static">
        <Toolbar>
          <Typography variant="h6">
            Car Shop | 자동차 거래소
          </Typography>
        </Toolbar>
      </AppBar>
    </Container>
  )
}

export default App

```

- Container 
  - 기본 레이아웃 컴포넌트에 해당, 앱 컨텐츠를 가로로 중앙에 배피됨
  - maxWidth를 통해 사이즈를 지정, 앱의 최대 너비(가로 길이)
- AppBar
  - positoion 프롭을 가지며, static으로 지정할 시 스크롤을 내릴 때 앱 바가 상단에 고정되지 않고 사라지게 됨. fixed일 경우 앱 바가 상단에 고정돼있음.
- CssBaseline
  - 여러 브라우저에서 리액트 앱의 모양이 균일하게 할 수 있도록 통제하는 Component
  - 보통 이 컴포넌트는 최상위 레벨에 포함되어 스타일이 전역적으로 적용되게끔 합니다. 물론 이상을 적용하기 위해 main.tsx에서 index.css import문을 삭제해줘야 합니다.


참고 자료 :

https://github.com/mui/material-ui 

https://mui.com/material-ui/getting-started/

# CRUD 기능 추가하기 

```tsx
      <QueryClientProvider client={queryClient}>

      </QueryClientProvider>
```

### 백엔드에서 데이터 가져오기 

```json

```

이상의 데이터를 바탕으로 에 데이터의 자료형을 정의 

이제 http://localhost:8080/api/cars 엔드 포인트로 요청을 날려서 백엔드에서 자동차 데이처를 가지고 오는 함수를 정의. 이 함수는 갹채 배열을 포함한 _프로미스_ 를 반환 -> 사용때 했음 

```tsx
import { useQuery } from "@tanstack/react-query";
import { CarResponse } from "../tsap";
import axios from "axios";

export default function Carlist() {
  const getCars = async (): Promise<CarResponse[]> => {
    const response = await axios.get(`http://localhost:8080/api/cars`);

    return response.data._embedded.cars;
  }

  const {data, error, isSuccess} = useQuery({
    queryKey: ['cars'],
    queryFn: getCars
  })

  return(
    <>
    
    </>
  );
}
```

- 참고사항 - 혹은 데이터를 가져오지도 않고 데이터의 자료형 또한 모르기 때문에 타입스크립트

```tsx
  const {data, error, isSuccess} = useQuery({
    queryKey: ['cars'],
    queryFn: getCars
  })
```

썼을 때 _조건부 렌더링_ 을 헸다. 

## 환경 변수 이용

백엔드가 로컬 호스트가 아닌 다른 서버에 배포가 된다고 가정했을 때 더이상 을 쓰지 않게 된다. 그러면 그때마다 백/프론트에 을 검색하고 하나하나 바꾼다고 생각하면 오류가 발생할 확률이 높다.

프로젝트 

```env
VITE_API_URl = http://localhost:8080
```

```ts
import axios from "axios";
import { CarResponse } from "../tsap";

const getCars = async (): Promise<CarResponse[]> => {
    const response = await axios.get(`${import.meta.env.VITE_API_URL}api/cars`);

    return response.data._embedded.cars;
  }
```

## 페이징, 필터링, 정렬 

npm install @mui/x-data-grid

```tsx
if(!isSuccess){
    return <span>Loading... </span>
  }

  else if (error) {
    return <span>데이터 가져오는 중에 오류 발생...</span>
  }

  else {
    return(
      <table>
        <tbody>
          {
            data.map((car: CarResponse) => 
              <tr key={car._links.self.href}>
                <td>{car.brand}</td>
                <td>{car.model}</td>
                <td>{car.color}</td>
                <td>{car.registrationNumber}</td>
                <td>{car.modelYear}</td>
                <td>{car.price}</td>
              </tr>
            )
          }
        </tbody>
      </table>
    )
  }
```

HTML 형태로 작성한 테이블을 x-data-grid로 교체

```tsx
  else {
    return(
      <DataGrid 
        rows={data}
        columns={columns}
        getRowId={row => row._links.self.href}
      />
    )
  }
```

## 삭제 기능 추가 

http://localhost:8080/api/cars/{carId} 엔드포인트 DELETE 메서드 요청을 전송하면 DB에서 해당 항목을 삭제 가능. 

JSON 데이터를 확인하게 되면 _links.self.href 노드에서 접근 가능한 링크가 있다. 

그리고 x-data-grid에는 모든 row에 대고 Id값을 _links.self.href로 설정을 해뒀다. -> 해당 고유값을 이용해서 특정 

1. 각 로우에 

```tsx
  export const deleteCar = async (link:string): Promise<CarResponse> => {
    const response = await axios.delete(link);
    return response.data
    
  }
```

메서드를 활용하여 메서드를 요청. 과의 차이점에 주목할 필요가 있다. 특정 자동차를 삭제하는 것이기 때문에 

이상으로 작성한 함수를 에서 사용해야 할거기 때문에 문이 쓰인다

```tsx
  const { mutata} = useMutation(deleteCar, {
    onSuccess: () => {
      //자동차 삭제 이후 실행되는 로직
    },
    onError: (err) => {
      console.log(err);
    },
  })

```

이렇게 작성하고, 

```tsx
<button onClick= {() => alert(params.row._links.self.href)}>
```

```tsx
<button onClick= {() => mutata(params.row._links.self.href)}>
```

이상의 과정을 거쳤을 때 삭제 버튼을 누르게 되면 바뀌는 게 없지만 

에서 가져온 데이터는 퀴리 클라이먼트가 처리하는 _커서_ 에 저장. 쿼리 클라이먼트에는 데이터를 다시 가져오는 데 이용할 수 있는 _쿼리 무효화_ 기능이 있다.

먼저 쿼리 클라이먼트를 반환하는 혹 함수를 

```tsx
      <DataGrid 
        rows={data}
        columns={columns}
        disableRowSelectionOnClick={true}
        getRowId={row => row._links.self.href}
      />
```

이상을 적용하게 되면 로우를 클릭했을 때 

## 토스트 메시지 표시 

UX상에 삭제를 성공했거나 오류가 있을 경우 사용자에게 피드백을 주면 좋을 것 같기에 

Toast Message라고 하는데 이것은 토스트 메세지를 처리하는 컴포넌트 영어 Snackbar

Snackbar 컴포넌트의 프롭 값은 입니다. 그래서 모달했을 대 대한 상태를 선언해야 한다. -> 때 학습한 내용이 일부 그대로 적용된다는 볼 수 있다. 

면 컴포넌트가 표시되고, 면 숨겨진다. -> 공톰점

으리가 생각하는 것은 삭제한 이후에 떠야 하는데 초기값은 

```tsx
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { getCars, deleteCar } from "../api/carapi";
import { DataGrid, GridColDef, GridCellParams } from "@mui/x-data-grid";
import { Snackbar } from "@mui/material";
import { useState } from "react";

export default function Carlist() {
  const queryClient = useQueryClient();

  const [open, setOpen] = useState(false);

  const {data, error, isSuccess} = useQuery({
    queryKey: ['cars'],
    queryFn: getCars
  });

  const { mutate } = useMutation(deleteCar, {
    onSuccess: () => {
      setOpen(true);
      queryClient.invalidateQueries({queryKey: ['cars']})
    },
    onError: (err) => {
      console.log(err);
    },
  })

  const columns: GridColDef[] = [
    {field: 'brand', headerName: 'Brand', width: 200},
    {field: 'model', headerName: '모델명', width: 200},
    {field: 'color', headerName: 'color', width: 200},
    {field: 'registrationNumber', headerName: '등록번호', width: 150},
    {field: 'modelYear', headerName: 'Model Tear', width: 150},
    {field: 'price', headerName: '가격', width: 150},
    {
      field: 'delete',
      headerName: '삭제',
      sortable: false,
      filterable: false,
      disableColumnMenu: true,
      renderCell: (params: GridCellParams) => (
        <button onClick= {() => mutate(params.row._links.self.href)}>
          Delete
        </button>
      ),
    },
  ]

  if(!isSuccess){
    return <span>Loading... </span>
  }

  else if (error) {
    return <span>데이터 가져오는 중에 오류 발생...</span>
  }

  else {
    return(
      <>
        <DataGrid 
          rows={data}
          columns={columns}
          disableRowSelectionOnClick={true}
          getRowId={row => row._links.self.href}
        />
        <Snackbar 
          open={open}
          autoHideDuration={2000}
          onClose={() => setOpen(false)}
          message='자동차가 삭제되었습니다. '
        /> 
      </>
      
    )
  }
}
```

## 확인 대화 상자 참 추가하기

실수로 자동차를 삭제하는 것을 막기 위해 삭제 버튼을 누른 후 확인 대화 상자를 표시하도록 작성할 예정

window 객체의 confirm 메서드를 이용하여 구현

confirm은 선택적 메시지가 있는 대화 상자로 ok를 누르면 를 반환하고, 누르면 메서드 종료 

버튼을 눌렀을 때 confirm 창이 떠야 한다. 
