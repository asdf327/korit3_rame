# 복습

## React로 이벤트 처리

1. onClick은 HTML의 onclick과 다름!

HTML에서는 이렇게 쓰죠:

```html
<button onclick="alert('hi')">Click</button>
```

React에서는 반드시 카멜케이스(onClick) 로 씁니다:

```tsx
<button onClick={handleClick}>Click</button>
```

- React는 JavaScript 기반이라서 속성 이름도 JavaScript 스타일을 따라야 함

- 그래서 onClick, onChange, onSubmit처럼 첫 글자를 소문자로, 중간 글자를 대문자로 쓴다. 

2. ✅ handleClick은 함수 "이름"만 넘겨야 함!

```jsx
<button onClick={handleClick}>Click!</button>  // ✅ 올바름
```

이렇게 하면:

- 버튼이 클릭되었을 때 handleClick 함수가 실행됩니다.

❌ 그런데 이런 식이면?

```jsx
<button onClick={handleClick()}>Click!</button>  // ❌ 잘못됨!
```

- 이렇게 작성하면 handleClick 함수가 클릭되기도 전에 자동 실행됩니다.

- onClick에는 "함수 그 자체"를 전달해야지, "함수 실행 결과"를 전달하면 안 돼요.

🎉 최종 요약

onClick은 React에서 카멜케이스로 써야 함

handleClick()이 아니라 handleClick만 전달해야 클릭할 때 실행됨

괄호 붙이면 즉시 실행되므로 주의!

### 카멜케이스(onClick)란

onClick과 같이 단어가 여러 개 합쳐진 형태에서 각 단어의 첫 글자를 대문자로 표기하는 방식을 **카멜 케이스(camelCase)**라고 부릅니다. 

#### 카멜 케이스의 특징 및 사용 예시

1. Lower Camel Case (소문자 시작 카멜 케이스)

- 첫 단어는 소문자로 시작하고, 이후 단어들의 첫 글자만 대문자로 표기합니다.
- 주로 _변수, 함수, 객체_ 의 속성 이름을 지을 때 사용됩니다.
- 예시:
  - myVariableName
  - calculateSum
  - getUserData
  - onClick (React, JavaScript 등에서 이벤트 핸들러 이름)
  - handleSubmit

2. Upper Camel Case (대문자 시작 카멜 케이스) 또는 파스칼 케이스(PascalCase)

- 모든 단어의 첫 글자를 대문자로 표기합니다.
- 주로 _클래스 이름, 컴포넌트 이름, 생성자 함수 이름_ 을 지을 때 사용됩니다.

- 예시:
  - MyComponent (React 컴포넌트 이름)
  - PersonClass
  - DatabaseConnection

#### 왜 카멜 케이스를 사용할까요?

- 가독성 향상: 여러 단어로 이루어진 이름을 붙여 쓸 경우(onclick), 단어 구분이 어려워 가독성이 떨어집니다. 카멜 케이스는 단어의 시작을 대문자로 구분하여 읽기 쉽게 만듭니다.

- 관례 및 표준: 많은 프로그래밍 언어(JavaScript, Java, C#, Swift 등)와 프레임워크(React, Angular, Vue 등)에서 카멜 케이스를 특정 요소(변수, 함수, 클래스 등)의 명명 규칙으로 권장하거나 강제합니다. 이는 코드의 일관성을 유지하고 협업을 용이하게 합니다.

- 혼란 방지: 하이픈(-)이나 언더스코어(_)를 사용하는 다른 명명 규칙(예: on-click 또는 on_click)과 구분하여 사용 목적을 명확히 합니다. 특히 JavaScript에서는 하이픈이 연산자로 인식될 수 있어 혼란을 줄 수 있습니다.

## React의 상태 관리 방식 중 "객체 vs 개별 state" 차이

🧾 상태 관리 방식 비교

- 하나의 user 객체를 state로 관리

```jsx
const [user, setUser] = useState({
  firstName: '',
  lastName: '',
  email: ''
});
```

장점: 상태를 하나로 묶어 관리할 수 있어 구조화된 데이터에 유리

단점: 필드를 하나만 바꿔도 전체 객체를 업데이트해야 하므로
→ Spread 연산자 필요!

- 예: onChange 함수 예시

```jsx
onChange={e =>
  setUser({ ...user, [e.target.name]: e.target.value })
}
```

✅ MyForm4

- 각각의 입력값을 개별 state로 관리

```jsx
const [firstName, setFirstName] = useState('');
const [lastName, setLastName] = useState('');
const [email, setEmail] = useState('');
```

장점: 단순하고 직관적, 개별 값 접근이 쉬움

단점: 입력 필드가 많아지면 state가 너무 많아짐


| 항목      | MyForm3 (객체형)         | MyForm4 (개별 변수형)      |
| ------- | --------------------- | --------------------- |
| 상태 개수   | 1개 (`user`)           | 3개 (`firstName`, ...) |
| 가독성     | 폼이 커지면 좋음             | 소규모 폼에 적합             |
| 필드 변경 시 | `...spread`로 전체 객체 복사 | 해당 state만 갱신          |
| 코드 복잡도  | 살짝 ↑                  | 단순하지만 많아짐             |

### Spread 연산자

스프레드 연산자는 문법적으로는 ... (점 3개)로 표현.

배열이나 객체 안에 묶여있던 값들을 하나하나 개별적인 값으로 만들어 주는 역할을 합니다.

이 연산자는 주로 두 가지 상황에서 사용.

1. 배열에서 ... 사용하기

배열에 있는 숫자나 문자 같은 값들을 하나씩 꺼내고 싶을 때 써요.

- 배열 복사하기 (새 보따리에 내용물 옮기기)

```jsx
const 내과일 = ['사과', '바나나'];
const 친구과일 = [...내과일]; // ['사과', '바나나']  <-- '내과일' 보따리를 풀어서 새 보따리에 넣음

친구과일.push('오렌지'); // 친구과일에만 오렌지 추가
console.log(내과일);   // ['사과', '바나나'] (나는 그대로)
console.log(친구과일); // ['사과', '바나나', '오렌지'] (친구는 오렌지 추가!)
```

- 배열 합치기 (두 보따리 내용물 한 보따리에)

여러 배열의 값들을 한 배열로 모을 때 편리해요. concat보다 더 직관적일 때가 많아요.

```jsx
const 아침메뉴 = ['토스트', '계란'];
const 점심메뉴 = ['샌드위치', '샐러드'];
const 하루식단 = [...아침메뉴, ...점심메뉴]; // ['토스트', '계란', '샌드위치', '샐러드']
```

- 함수에 값 넘겨주기 (보따리 풀어서 하나씩 건네주기)

함수가 여러 개의 인자를 받아야 할 때, 배열에 있는 값들을 마치 하나하나 따로 넣어주는 것처럼 쓸 수 있어요.

```jsx
function 가장큰수찾기(a, b, c) {
    return Math.max(a, b, c);
}

const 숫자들 = [10, 50, 20];
const 최대값 = 가장큰수찾기(...숫자들); // 가장큰수찾기(10, 50, 20) 와 똑같아요!
console.log(최대값); // 50
```

2. 객체에서 ... 사용하기

객체 안에 있는 속성(key: value)들을 하나씩 꺼낼 때 써요.

- 객체 복사하기 (새 주머니에 물건 옮기기)

배열처럼, 기존 객체를 건드리지 않고 똑같은 내용을 가진 새 객체를 만들 때 사용해요.

```jsx
const 내정보 = { 이름: '김코딩', 나이: 30 };
const 새정보 = { ...내정보 }; // { 이름: '김코딩', 나이: 30 }

새정보.나이 = 31; // 새정보에만 나이 변경
console.log(내정보); // { 이름: '김코딩', 나이: 30 } (나는 그대로)
console.log(새정보); // { 이름: '김코딩', 나이: 31 } (새정보는 나이 변경!)
```

- 객체 합치기 (두 주머니 물건 한 주머니에)

여러 객체의 속성들을 하나의 새로운 객체로 모을 때 사용해요. _만약 같은 이름의 속성이 있다면, 나중에 오는 객체의 속성이 이전 것을 덮어써요._

```jsx
const 기본정보 = { 이름: '박개발', 직업: '개발자' };
const 연락처정보 = { 이메일: 'dev@example.com', 전화: '010-1234-5678' };

const 전체정보 = { ...기본정보, ...연락처정보 };
// { 이름: '박개발', 직업: '개발자', 이메일: 'dev@example.com', 전화: '010-1234-5678' }
```

- 객체 속성 업데이트 (일부만 바꿔서 새 주머니 만들기)

기존 객체는 그대로 두고, 일부 속성만 바뀐 새로운 객체를 만들 때 아주 편리해요. React 같은 라이브러리에서 많이 사용돼요.

```jsx
const 상품 = { 이름: '노트북', 가격: 1000000, 색상: '실버' };
const 할인상품 = { ...상품, 가격: 900000, 색상: '블랙' }; // 가격과 색상만 변경
console.log(할인상품); // { 이름: '노트북', 가격: 900000, 색상: '블랙' }
```

#### 헷갈리지 마세요! ...가 두 가지 얼굴?

...는 스프레드 연산자와 Rest 파라미터 두 가지로 사용돼요.

스프레드 연산자: ...는 "있는 걸 펼쳐서 주는" 역할

예: [...myArray], {...myObject}

Rest 파라미터: ...는 "나머지 것들을 한데 모아 받는" 역할 (주로 함수 매개변수에서)

예: function myFunc(a, b, ...나머지인자들) { ... }

스프레드 연산자는 코드를 더 짧고 읽기 좋게 만들어주는 아주 유용한 기능이랍니다!

### 💥 Spread 연산자 (...) 왜 필요한가요?

객체나 배열을 수정할 때, 불변성(immutable) 을 지켜야 하기 때문입니다.

```jsx
// 잘못된 예 (직접 수정)
user.firstName = '홍';

// 올바른 예
setUser({ ...user, firstName: '홍' });
```

이렇게 하면 React가 state 변경을 인식하고 UI도 새로 렌더링됩니다.